package main

import (
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"
	"syscall"
)

type measurement struct {
	total float64
	count int
	max   float64
	min   float64
}

func main() {
	// Open the file
	measurementsMap := make(map[string]measurement)

	file, err := os.Open("large_dataset.txt")
	if err != nil {
		fmt.Println("Error opening file:", err)
		return
	}
	defer file.Close()

	// Get file information
	fileInfo, err := file.Stat()
	if err != nil {
		fmt.Println("Error getting file info:", err)
		return
	}

	// Memory-map the file
	data, err := syscall.Mmap(int(file.Fd()), 0, int(fileInfo.Size()), syscall.PROT_READ, syscall.MAP_SHARED)
	if err != nil {
		fmt.Println("Error mapping file:", err)
		return
	}
	defer syscall.Munmap(data)

	// Initialize variables for line parsing
	lineOffsets := []int{0}
	lineCount := 100000000 // Assume we know there are 1000 lines

	// Scan the file to find line offsets
	for i, b := range data {
		if b == '\n' {
			lineOffsets = append(lineOffsets, i+1)
			if len(lineOffsets) > lineCount {
				break
			}
		}
	}

	// Print the lines using offsets
	for i := 0; i < len(lineOffsets)-1; i++ {
		lineStart := lineOffsets[i]
		lineEnd := lineOffsets[i+1]
		line := data[lineStart:lineEnd]

		parts := strings.Split(string(line), ";")
		station := parts[0]
		mes, _ := strconv.ParseFloat(strings.Trim(parts[1], "\n"), 64)

		measurementsMap[station] = measurement{
			total: mes + measurementsMap[station].total,
			count: measurementsMap[station].count + 1,
			max:   math.Max(mes, measurementsMap[station].max),
			min:   math.Min(mes, measurementsMap[station].min),
		}
	}

	for k, v := range measurementsMap {
		fmt.Printf("Station: %s, Mean: %f, Max: %f, Min: %f\n", k, v.total/float64(v.count), v.max, v.min)
	}
}
