package main

/*import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
	"sync"

	"golang.org/x/exp/mmap"
)

/* EXAMPLE INPUT
Hamburg;12.0
Bulawayo;8.9
Palembang;38.8
St. John's;15.2
Cracow;12.6
Bridgetown;26.9
Istanbul;6.2
Roseau;34.4
Conakry;31.2
Istanbul;23.0
*/

func processLine(line string, lineNumber int) (string, float64) {
	parts := strings.Split(line, ";")
	station := parts[0]
	measurement, _ := strconv.ParseFloat(parts[1], 64)

	return station, measurement
}

// func processChunk(chunk []byte, chunkNumber int, wg *sync.WaitGroup) []string {
func processChunk(chunk []byte, chunkNumber int, wg *sync.WaitGroup) {
	defer wg.Done()

	scanner := bufio.NewScanner(NewChunkReader(chunk))
	lineNumber := 1
	for scanner.Scan() {
		//lines = append(lines, scanner.Text())
		line := scanner.Text()
		_ = line
		lineNumber++
	}

	//return lines
}

type ChunkReader struct {
	data []byte
	pos  int
}

func NewChunkReader(data []byte) *ChunkReader {
	return &ChunkReader{data: data}
}

func (r *ChunkReader) Read(p []byte) (int, error) {
	if r.pos >= len(r.data) {
		return 0, io.EOF
	}
	n := copy(p, r.data[r.pos:])
	r.pos += n
	return n, nil
}

func main() {
	filePath := "large_dataset.txt"
	chunkSize := 64 * 1024 * 1024

	reader, _ := mmap.Open(filePath)
	defer reader.Close()

	fileInfo, _ := os.Stat(filePath)
	fileSize := fileInfo.Size()
	fmt.Printf("File size: %d bytes\n", fileSize)

	var wg sync.WaitGroup
	for offset := int64(0); offset < fileSize; {
		remainingSize := fileSize - offset
		currentChunkSize := int64(chunkSize)
		if remainingSize < currentChunkSize {
			currentChunkSize = remainingSize
		}

		largeChunk := make([]byte, currentChunkSize+1024)
		n, _ := reader.ReadAt(largeChunk, offset)
		actualChunkSize := int64(n)
		if idx := strings.LastIndexByte(string(largeChunk[:n]), '\n'); idx >= 0 {
			actualChunkSize = int64(idx + 1)
		}

		chunk := largeChunk[:actualChunkSize]
		offset += actualChunkSize

		wg.Add(1)
		go processChunk(chunk, int(offset/int64(chunkSize)), &wg)
	}

	wg.Wait()
}
